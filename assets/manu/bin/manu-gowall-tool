#!/usr/bin/env bash

#    ┏┓┏┓┓ ┏┏┓┓ ┓
#    ┃┓┃┃┃┃┃┣┫┃ ┃
#    ┗┛┗┛┗┻┛┛┗┗┛┗┛
#    ┳┳┳┓┏┓┏┓┏┓  ┏┳┓┏┓┏┓┓
#    ┃┃┃┃┣┫┃┓┣    ┃ ┃┃┃┃┃
#    ┻┛ ┗┛┗┗┛┗┛   ┻ ┗┛┗┛┗┛
#                  

set -o pipefail

# ============================================================
#  Dependency Checks
# ============================================================
if ! command -v gowall >/dev/null 2>&1; then
  echo "  Error: 'gowall' not found. Please install it first." >&2
  exit 1
fi

if ! command -v gum >/dev/null 2>&1; then
  echo "  Error: 'gum' not found. Install gum (>= 0.17.0)." >&2
  exit 1
fi

# ============================================================
#  Version Check
# ============================================================
gowall_version=$(gowall -v 2>/dev/null | grep -oP '\d+\.\d+\.\d+' | head -1)
min_version="0.2.3"
version_lt() { [ "$(printf '%s\n%s\n' "$1" "$2" | sort -V | head -n1)" != "$2" ]; }

if [ -n "$gowall_version" ] && version_lt "$gowall_version" "$min_version"; then
  echo "  Warning: gowall $gowall_version detected. Recommended: $min_version+" >&2
fi

# ============================================================
#  Catppuccin Mocha Theme Colors
# ============================================================
MOCHA_TEXT="#cdd6f4"
MOCHA_SUBTEXT="#9399b2"
MOCHA_ACCENT="#cba6f7"
MOCHA_GREEN="#a6e3a1"
MOCHA_RED="#f38ba8"
MOCHA_BLUE="#89b4fa"
MOCHA_PEACH="#fab387"
MOCHA_OVERLAY="#45475a"

# Export colors for gum widgets
export GUM_INPUT_PROMPT_FOREGROUND="$MOCHA_TEXT"
export GUM_INPUT_CURSOR_FOREGROUND="$MOCHA_ACCENT"
export GUM_INPUT_PLACEHOLDER_FOREGROUND="$MOCHA_SUBTEXT"
export GUM_CHOOSE_CURSOR_FOREGROUND="$MOCHA_ACCENT"
export GUM_CHOOSE_SELECTED_FOREGROUND="$MOCHA_ACCENT"
export GUM_CHOOSE_UNSELECTED_FOREGROUND="$MOCHA_TEXT"
export GUM_CHOOSE_SELECTED_BACKGROUND="$MOCHA_OVERLAY"
export GUM_CONFIRM_PROMPT_FOREGROUND="$MOCHA_TEXT"
export GUM_CONFIRM_SELECTED_FOREGROUND="$MOCHA_ACCENT"
export GUM_CONFIRM_UNSELECTED_FOREGROUND="$MOCHA_TEXT"
export GUM_FILTER_PROMPT_FOREGROUND="$MOCHA_TEXT"
export GUM_FILTER_CURSOR_FOREGROUND="$MOCHA_ACCENT"
export GUM_FILTER_SELECTED_FOREGROUND="$MOCHA_ACCENT"
export GUM_FILTER_UNSELECTED_FOREGROUND="$MOCHA_TEXT"
export GUM_FILTER_PLACEHOLDER_FOREGROUND="$MOCHA_SUBTEXT"
export GUM_FILE_CURSOR_FOREGROUND="$MOCHA_ACCENT"
export GUM_FILE_SELECTED_FOREGROUND="$MOCHA_ACCENT"
export GUM_FILE_UNSELECTED_FOREGROUND="$MOCHA_TEXT"

# ============================================================
#  TrueColor Icon Coloring (inline ANSI)
#  Set USE_TRUECOLOR_ICONS=false to disable colored icons in menu
# ============================================================
USE_TRUECOLOR_ICONS=${USE_TRUECOLOR_ICONS:-true}

hex_to_rgb_escape() {
  # Prints an ANSI 24-bit foreground color escape sequence from hex
  # Usage: hex_to_rgb_escape "#rrggbb"
  local hex="${1#\#}"
  local r=$((16#${hex:0:2}))
  local g=$((16#${hex:2:2}))
  local b=$((16#${hex:4:2}))
  printf "\033[38;2;%d;%d;%dm" "$r" "$g" "$b"
}

RESET="\033[0m"
if [ "$USE_TRUECOLOR_ICONS" = "true" ]; then
  ICON_BLUE=$(hex_to_rgb_escape "$MOCHA_BLUE")
  ICON_GREEN=$(hex_to_rgb_escape "$MOCHA_GREEN")
  ICON_RED=$(hex_to_rgb_escape "$MOCHA_RED")
  ICON_PEACH=$(hex_to_rgb_escape "$MOCHA_PEACH")
  ICON_ACCENT=$(hex_to_rgb_escape "$MOCHA_ACCENT")
  ICON_TEXT=$(hex_to_rgb_escape "$MOCHA_TEXT")
  ICON_SUBTEXT=$(hex_to_rgb_escape "$MOCHA_SUBTEXT")
else
  ICON_BLUE=""
  ICON_GREEN=""
  ICON_RED=""
  ICON_PEACH=""
  ICON_ACCENT=""
  ICON_TEXT=""
  ICON_SUBTEXT=""
  RESET=""
fi

# A reusable "Back" label with icon
BACK_LABEL="${ICON_SUBTEXT}${RESET}  Main menu"

# ============================================================
#  Banner (Compact, Blue)
# ============================================================
show_banner() {
  clear
  gum style \
    --foreground "$MOCHA_BLUE" \
    --bold \
    "      ___           ___           ___           ___           ___       ___ " \
    "     /\\  \\         /\\  \\         /\\__\\         /\\  \\         /\\__\\     /\\__\\ " \
    "    /::\\  \\       /::\\  \\       /:/ _/_       /::\\  \\       /:/  /    /:/  / " \
    "   /:/\\:\\  \\     /:/\\:\\  \\     /:/ /\\__\\     /:/\\:\\  \\     /:/  /    /:/  /  " \
    "  /:/  \\:\\  \\   /:/  \\:\\  \\   /:/ /:/ _/_   /::\\~\\:\\  \\   /:/  /    /:/  /   " \
    " /:/__/_\\:\\__\\ /:/__/ \\:\\__\\ /:/_/:/ /\\__\\ /:/\\:\\ \\:\\__\\ /:/__/    /:/__/    " \
    " \\:\\  /\\ \\/__/ \\:\\  \\ /:/  / \\:\\/:/ /:/  / \\/__\\:\\/:/  / \\:\\  \\    \\:\\  \\    " \
    "  \\:\\ \\:\\__\\    \\:\\  /:/  /   \\::/_/:/  /       \\::/  /   \\:\\  \\    \\:\\  \\   " \
    "   \\:\\/:/  /     \\:\\/:/  /     \\:\\/:/  /        /:/  /     \\:\\  \\    \\:\\  \\  " \
    "    \\::/  /       \\::/  /       \\::/  /        /:/  /       \\:\\__\\    \\:\\__\\ " \
    "     \\/__/         \\/__/         \\/__/         \\/__/         \\/__/     \\/__/  "
  echo ""
}

# ============================================================
#  Helper Functions (UI messages)
# ============================================================
show_success() { gum style --foreground "$MOCHA_GREEN" "  $1"; }
show_error() { gum style --foreground "$MOCHA_RED" "  $1"; }
show_info() { gum style --foreground "$MOCHA_BLUE" "  $1"; }

pause_continue() {
  gum input --placeholder "Press Enter to continue..."
}

# ============================================================
#  File & Directory Pickers
# ============================================================
# Function: choose a file (with Back)
choose_file() {
  local prompt="$1"
  local method=$(printf "%b\n%b\n%b" \
    "${ICON_TEXT}${RESET}  Enter path manually" \
    "${ICON_ACCENT}${RESET}  Browse filesystem" \
    "$BACK_LABEL" |
    gum choose --header "$prompt")
  local file_path=""

  if [[ "$method" == *"Main menu"* ]]; then
    return 1
  fi

  if [[ $method == *"Enter path"* ]]; then
    file_path=$(gum input --placeholder "~/path/to/image.png")
    [ -z "$file_path" ] && return 1
    file_path="${file_path/#\~/$HOME}"
  else
    if command -v fzf >/dev/null 2>&1; then
      file_path=$(find ~ -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" -o -iname "*.svg" -o -iname "*.pdf" \) 2>/dev/null |
        fzf --height 50% --prompt="Select file: " --preview 'file {}' --preview-window=right:40%)
    else
      file_path=$(gum file ~)
    fi
    [ -z "$file_path" ] && return 1
  fi

  file_path=$(realpath -m "$file_path" 2>/dev/null || echo "$file_path")
  if [ ! -f "$file_path" ]; then
    gum confirm "  File '$file_path' not found. Continue anyway?" || return 1
  fi
  echo "$file_path"
}

# Function: choose a directory (with Back)
choose_directory() {
  local prompt="$1"
  local method=$(printf "%b\n%b\n%b" \
    "${ICON_TEXT}${RESET}  Enter path manually" \
    "${ICON_ACCENT}${RESET}  Browse filesystem" \
    "$BACK_LABEL" |
    gum choose --header "$prompt")
  local dir_path=""

  if [[ "$method" == *"Main menu"* ]]; then
    return 1
  fi

  if [[ $method == *"Enter path"* ]]; then
    dir_path=$(gum input --placeholder "~/path/to/directory")
    [ -z "$dir_path" ] && return 1
    dir_path="${dir_path/#\~/$HOME}"
  else
    if command -v fzf >/dev/null 2>&1; then
      dir_path=$(find ~ -type d 2>/dev/null | fzf --height 40% --prompt="Select directory: ")
    else
      dir_path=$(gum file --directory ~)
    fi
    [ -z "$dir_path" ] && return 1
  fi

  dir_path=$(realpath -m "$dir_path" 2>/dev/null || echo "$dir_path")
  if [ ! -d "$dir_path" ]; then
    if gum confirm "  Create directory '$dir_path'?"; then
      mkdir -p "$dir_path" || {
        show_error "Failed to create directory"
        return 1
      }
    else
      return 1
    fi
  fi
  echo "$dir_path"
}

# ============================================================
#  Load Available Themes (fallback list if gowall fails)
# ============================================================
theme_list=$(gowall list 2>/dev/null || echo "catppuccin\ngruvbox\nnord\neverforest\nsolarized")

# ============================================================
#  Small helpers for optional output path/dir
# ============================================================
ask_output_path_flag() {
  # Ask for a single output file path, return flag string or empty
  local out_flag=""
  local answer=$(printf "%b\n%b" \
    "${ICON_ACCENT}${RESET}  Specify output path" \
    "$BACK_LABEL" |
    gum choose --header "Output:")
  if [[ "$answer" == *"Main menu"* ]]; then
    echo ""
    return 1
  fi

  local out_path
  out_path=$(gum input --placeholder "~/output/image.png or ~/output/")
  if [ -n "$out_path" ]; then
    out_path="${out_path/#\~/$HOME}"
    mkdir -p "$(dirname "$out_path")" 2>/dev/null || true
    out_flag="--output $out_path"
  fi
  echo "$out_flag"
  return 0
}

ask_output_dir_flag() {
  # Ask for an output directory, return flag string or empty
  local out_flag=""
  local answer=$(printf "%b\n%b" \
    "${ICON_ACCENT}${RESET}  Specify output directory" \
    "$BACK_LABEL" |
    gum choose --header "Output:")
  if [[ "$answer" == *"Main menu"* ]]; then
    echo ""
    return 1
  fi
  local out_dir
  out_dir=$(choose_directory "Output directory:") || {
    echo ""
    return 1
  }
  out_flag="--output $out_dir"
  echo "$out_flag"
  return 0
}

# ============================================================
#  Main Menu Loop
# ============================================================
while true; do
  show_banner

  main_choice=$(
    printf "%b\n%b\n%b\n%b\n%b\n%b\n%b\n%b\n%b\n%b\n%b\n%b\n%b\n%b" \
      "${ICON_BLUE}${RESET}  Convert image theme/colors" \
      "${ICON_ACCENT}${RESET}  Pixel art (pixelate)" \
      "${ICON_PEACH}${RESET}  Draw border/grid" \
      "${ICON_RED}${RESET}  Remove background" \
      "${ICON_ACCENT}${RESET}  Image effects" \
      "${ICON_PEACH}${RESET}  Create GIF animation" \
      "${ICON_GREEN}${RESET}  AI Upscale (4x)" \
      "${ICON_ACCENT}${RESET}  Compress image" \
      "${ICON_ACCENT}${RESET}  Extract color palette" \
      "${ICON_BLUE}${RESET}  Invert colors" \
      "${ICON_TEXT}${RESET}  List themes" \
      "${ICON_ACCENT}${RESET}  OCR (extract text)" \
      "${ICON_BLUE}${RESET}  Wallpaper of the day" \
      "${ICON_SUBTEXT}${RESET}  Exit" |
      gum choose --height 16 --header "Select operation:"
  )

  # If user cancels (Ctrl+C) or empty, restart loop
  [ -z "$main_choice" ] && continue

  case "$main_choice" in

  # --------------------------------------------------------
  # Convert
  # --------------------------------------------------------
  *"Convert image"*)
    conv_choice=$(
      printf "%b\n%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Apply color theme" \
        "${ICON_PEACH}${RESET}  Replace specific color" \
        "${ICON_BLUE}${RESET}  Change format (png/jpg/webp)" \
        "$BACK_LABEL" |
        gum choose --header "Conversion type:"
    )
    [[ "$conv_choice" == *"Main menu"* || -z "$conv_choice" ]] && continue

    if [[ $conv_choice == *"Apply color theme"* ]]; then
      input=$(choose_file "Select image to convert:") || {
        pause_continue
        continue
      }
      theme=$(
        {
          echo -e "$theme_list"
          echo "$BACK_LABEL"
        } | gum choose --header "Select theme:"
      )
      [[ "$theme" == *"Main menu"* || -z "$theme" ]] && {
        pause_continue
        continue
      }

      out_flag=$(ask_output_path_flag)
      [ $? -eq 1 ] && {
        pause_continue
        continue
      }

      show_info "Converting to theme '$theme'..."
      if output=$(gowall convert "$input" -t "$theme" $out_flag 2>&1); then
        show_success "Conversion complete."
        [ -n "$out_flag" ] && echo "  → Saved: ${out_flag#--output }"
      else
        show_error "Conversion failed: $output"
      fi

    elif [[ $conv_choice == *"Replace specific color"* ]]; then
      input=$(choose_file "Select image:") || {
        pause_continue
        continue
      }
      orig_col=$(gum input --placeholder "Color to replace (#HEX)" --value "#FFFFFF") || {
        pause_continue
        continue
      }
      new_col=$(gum input --placeholder "New color (#HEX)" --value "#000000") || {
        pause_continue
        continue
      }
      thresh=$(gum input --placeholder "Threshold 0-100 (optional)" --value "10") || true

      replace_arg="$orig_col,$new_col"
      [ -n "$thresh" ] && replace_arg="$replace_arg,$thresh"

      out_flag=$(ask_output_path_flag)
      [ $? -eq 1 ] && {
        pause_continue
        continue
      }

      show_info "Replacing $orig_col → $new_col..."
      if output=$(gowall convert "$input" -r "$replace_arg" $out_flag 2>&1); then
        show_success "Color replaced."
        [ -n "$out_flag" ] && echo "  → Saved: ${out_flag#--output }"
      else
        show_error "$output"
      fi

    else
      input=$(choose_file "Select image:") || {
        pause_continue
        continue
      }
      format=$(
        printf "png\njpg\njpeg\nwebp\n%s" "$BACK_LABEL" | gum choose --header "Target format:"
      )
      [[ "$format" == *"Main menu"* || -z "$format" ]] && {
        pause_continue
        continue
      }

      out_flag=$(ask_output_path_flag)
      [ $? -eq 1 ] && {
        pause_continue
        continue
      }

      show_info "Converting to .$format..."
      if output=$(gowall convert "$input" -f "$format" $out_flag 2>&1); then
        show_success "Format converted."
        [ -n "$out_flag" ] && echo "  → Saved: ${out_flag#--output }"
      else
        show_error "$output"
      fi
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Pixel Art (pixelate)
  # --------------------------------------------------------
  *"Pixel art"*)
    input_mode=$(
      printf "%b\n%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Single image" \
        "${ICON_ACCENT}${RESET}  Multiple images" \
        "${ICON_ACCENT}${RESET}  Entire directory" \
        "$BACK_LABEL" |
        gum choose --header "Process:"
    )
    [[ "$input_mode" == *"Main menu"* || -z "$input_mode" ]] && continue

    args=""
    case $input_mode in
    *"Single image"*)
      file=$(choose_file "Select image:") || {
        pause_continue
        continue
      }
      args="$file"
      ;;
    *"Multiple images"*)
      dir=$(choose_directory "Select directory with images:") || {
        pause_continue
        continue
      }
      files=$(find "$dir" -maxdepth 1 -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" \) -printf "%f\n")
      [ -z "$files" ] && {
        show_error "No images found"
        pause_continue
        continue
      }
      selected=$( (
        echo "$files"
        echo "Main menu"
      ) | gum filter --no-limit --placeholder "Select images (Tab=multi)")
      [[ "$selected" == *"Main menu"* || -z "$selected" ]] && {
        pause_continue
        continue
      }
      batch_list=$(echo "$selected" | grep -v "^Main menu$" | sed "s|^|$dir/|" | paste -sd, -)
      args="--batch $batch_list"
      ;;
    *"Entire directory"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      args="--dir $dir"
      ;;
    esac

    scale=$(gum input --value "15" --placeholder "Pixel scale (1-25, lower=more pixelated)")
    [ -z "$scale" ] && {
      pause_continue
      continue
    }

    out_flag=$(ask_output_dir_flag)
    [ $? -eq 1 ] && {
      pause_continue
      continue
    }

    show_info "Applying pixel art effect (scale=$scale)..."
    if output=$(gowall pixelate $args -s "$scale" $out_flag 2>&1); then
      show_success "Pixel art created."
      [ -n "$out_flag" ] && echo "  → Saved to: ${out_flag#--output }"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Draw border/grid
  # --------------------------------------------------------
  *"Draw border/grid"*)
    draw_type=$(
      printf "%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Border" \
        "${ICON_ACCENT}${RESET}  Grid" \
        "$BACK_LABEL" |
        gum choose --header "Draw type:"
    )
    [[ "$draw_type" == *"Main menu"* || -z "$draw_type" ]] && continue

    input=$(choose_file "Select image:") || {
      pause_continue
      continue
    }

    if [[ $draw_type == *"Border"* ]]; then
      color=$(gum input --placeholder "Border color (#HEX)" --value "#FFFFFF") || {
        pause_continue
        continue
      }
      thickness=$(gum input --placeholder "Thickness (px)" --value "5") || {
        pause_continue
        continue
      }
      out_flag=$(ask_output_path_flag)
      [ $? -eq 1 ] && {
        pause_continue
        continue
      }

      show_info "Drawing border..."
      if output=$(gowall draw border "$input" -c "$color" -b "$thickness" $out_flag 2>&1); then
        show_success "Border drawn."
        [ -n "$out_flag" ] && echo "  → Saved: ${out_flag#--output }"
      else
        show_error "$output"
      fi
    else
      grid_color=$(gum input --placeholder "Grid color (#HEX, optional)" --value "#FFFFFF")
      grid_size=$(gum input --placeholder "Cell size (px, optional)" --value "32")
      thickness=$(gum input --placeholder "Line thickness (px, optional)" --value "1")

      flags=""
      [ -n "$grid_color" ] && flags="$flags -c $grid_color"
      [ -n "$grid_size" ] && flags="$flags -s $grid_size"
      [ -n "$thickness" ] && flags="$flags -t $thickness"

      only_transparent=$(printf "No\nYes\n%s" "$BACK_LABEL" | gum choose --header "Apply only to transparent areas?")
      [[ "$only_transparent" == *"Main menu"* || -z "$only_transparent" ]] && {
        pause_continue
        continue
      }
      if [[ "$only_transparent" == "Yes" ]]; then
        flags="$flags -m true"
      fi

      out_flag=$(ask_output_path_flag)
      [ $? -eq 1 ] && {
        pause_continue
        continue
      }

      show_info "Drawing grid..."
      if output=$(gowall draw grid "$input" $flags $out_flag 2>&1); then
        show_success "Grid drawn."
        [ -n "$out_flag" ] && echo "  → Saved: ${out_flag#--output }"
      else
        show_error "$output"
      fi
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Remove background
  # --------------------------------------------------------
  *"Remove background"*)
    input_mode=$(
      printf "%b\n%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Single image" \
        "${ICON_ACCENT}${RESET}  Multiple images" \
        "${ICON_ACCENT}${RESET}  Entire directory" \
        "$BACK_LABEL" |
        gum choose --header "Process:"
    )
    [[ "$input_mode" == *"Main menu"* || -z "$input_mode" ]] && continue

    args=""
    case $input_mode in
    *"Single image"*)
      file=$(choose_file "Select image:") || {
        pause_continue
        continue
      }
      args="$file"
      ;;
    *"Multiple images"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      files=$(find "$dir" -maxdepth 1 -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" \) -printf "%f\n")
      [ -z "$files" ] && {
        show_error "No images found"
        pause_continue
        continue
      }
      selected=$( (
        echo "$files"
        echo "Main menu"
      ) | gum filter --no-limit)
      [[ "$selected" == *"Main menu"* || -z "$selected" ]] && {
        pause_continue
        continue
      }
      batch_list=$(echo "$selected" | grep -v "^Main menu$" | sed "s|^|$dir/|" | paste -sd, -)
      args="--batch $batch_list"
      ;;
    *"Entire directory"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      args="--dir $dir"
      ;;
    esac

    out_flag=$(ask_output_dir_flag)
    [ $? -eq 1 ] && {
      pause_continue
      continue
    }

    show_info "Removing background..."
    if output=$(gowall bg $args $out_flag 2>&1); then
      show_success "Background removed."
      [ -n "$out_flag" ] && echo "  → Saved to: ${out_flag#--output }"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Image effects
  # --------------------------------------------------------
  *"Image effects"*)
    effect=$(
      printf "%b\n%b\n%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Flip horizontal" \
        "${ICON_ACCENT}${RESET}  Mirror" \
        "${ICON_ACCENT}${RESET}  Brightness" \
        "${ICON_ACCENT}${RESET}  Grayscale" \
        "$BACK_LABEL" |
        gum choose --header "Effect:"
    )
    [[ "$effect" == *"Main menu"* || -z "$effect" ]] && continue

    case $effect in
    *"Flip horizontal"*) sub="flip" ;;
    *"Mirror"*) sub="mirror" ;;
    *"Brightness"*) sub="br" ;;
    *"Grayscale"*) sub="grayscale" ;;
    *) continue ;;
    esac

    input_mode=$(
      printf "%b\n%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Single image" \
        "${ICON_ACCENT}${RESET}  Multiple images" \
        "${ICON_ACCENT}${RESET}  Directory" \
        "$BACK_LABEL" |
        gum choose --header "Process:"
    )
    [[ "$input_mode" == *"Main menu"* || -z "$input_mode" ]] && continue

    args=""
    case $input_mode in
    *"Single image"*)
      file=$(choose_file "Select image:") || {
        pause_continue
        continue
      }
      args="$file"
      ;;
    *"Multiple images"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      files=$(find "$dir" -maxdepth 1 -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" \) -printf "%f\n")
      [ -z "$files" ] && {
        show_error "No images found"
        pause_continue
        continue
      }
      selected=$( (
        echo "$files"
        echo "Main menu"
      ) | gum filter --no-limit)
      [[ "$selected" == *"Main menu"* || -z "$selected" ]] && {
        pause_continue
        continue
      }
      batch_list=$(echo "$selected" | grep -v "^Main menu$" | sed "s|^|$dir/|" | paste -sd, -)
      args="--batch $batch_list"
      ;;
    *"Directory"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      args="--dir $dir"
      ;;
    esac

    extra=""
    if [ "$sub" = "br" ]; then
      factor=$(gum input --placeholder "Brightness factor (0.5-2.0)" --value "1.2")
      [ -z "$factor" ] && {
        pause_continue
        continue
      }
      extra="-f $factor"
    fi

    out_flag=$(ask_output_dir_flag)
    [ $? -eq 1 ] && {
      pause_continue
      continue
    }

    show_info "Applying effect '$sub'..."
    if output=$(gowall effects $sub $args $extra $out_flag 2>&1); then
      show_success "Effect applied."
      [ -n "$out_flag" ] && echo "  → Saved to: ${out_flag#--output }"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Create GIF
  # --------------------------------------------------------
  *"Create GIF animation"*)
    mode=$(
      printf "%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Select specific images" \
        "${ICON_ACCENT}${RESET}  Use all in directory" \
        "$BACK_LABEL" |
        gum choose --header "Mode:"
    )
    [[ "$mode" == *"Main menu"* || -z "$mode" ]] && continue

    args=""
    if [[ $mode == *"specific images"* ]]; then
      dir=$(choose_directory "Directory with frames:") || {
        pause_continue
        continue
      }
      files=$(find "$dir" -maxdepth 1 -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" \) -printf "%f\n")
      [ -z "$files" ] && {
        show_error "No images found"
        pause_continue
        continue
      }
      selected=$( (
        echo "$files"
        echo "Main menu"
      ) | gum filter --no-limit --placeholder "Select frames (in order)")
      [[ "$selected" == *"Main menu"* || -z "$selected" ]] && {
        pause_continue
        continue
      }
      batch_list=$(echo "$selected" | grep -v "^Main menu$" | sed "s|^|$dir/|" | paste -sd, -)
      args="--batch $batch_list"
    else
      dir=$(choose_directory "Directory with images:") || {
        pause_continue
        continue
      }
      args="--dir $dir"
    fi

    delay=$(gum input --placeholder "Frame delay (centiseconds, 100=1sec)" --value "100")
    [ -z "$delay" ] && {
      pause_continue
      continue
    }
    loops=$(gum input --placeholder "Loops (0=infinite)" --value "0")
    [ -z "$loops" ] && {
      pause_continue
      continue
    }
    args="$args -d $delay -l $loops"

    out_flag=$(ask_output_path_flag)
    [ $? -eq 1 ] && {
      pause_continue
      continue
    }

    show_info "Creating GIF animation..."
    if output=$(gowall gif $args $out_flag 2>&1); then
      show_success "GIF created."
      [ -n "$out_flag" ] && echo "  → Saved: ${out_flag#--output }"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # AI Upscale
  # --------------------------------------------------------
  *"AI Upscale (4x)"*)
    input_mode=$(
      printf "%b\n%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Single image" \
        "${ICON_ACCENT}${RESET}  Multiple images" \
        "${ICON_ACCENT}${RESET}  Directory" \
        "$BACK_LABEL" |
        gum choose --header "Process:"
    )
    [[ "$input_mode" == *"Main menu"* || -z "$input_mode" ]] && continue

    args=""
    case $input_mode in
    *"Single image"*)
      file=$(choose_file "Select image:") || {
        pause_continue
        continue
      }
      args="$file"
      ;;
    *"Multiple images"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      files=$(find "$dir" -maxdepth 1 -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" \) -printf "%f\n")
      [ -z "$files" ] && {
        show_error "No images found"
        pause_continue
        continue
      }
      selected=$( (
        echo "$files"
        echo "Main menu"
      ) | gum filter --no-limit)
      [[ "$selected" == *"Main menu"* || -z "$selected" ]] && {
        pause_continue
        continue
      }
      batch_list=$(echo "$selected" | grep -v "^Main menu$" | sed "s|^|$dir/|" | paste -sd, -)
      args="--batch $batch_list"
      ;;
    *"Directory"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      args="--dir $dir"
      ;;
    esac

    scale=$(printf "2\n3\n4\n%s" "$BACK_LABEL" | gum choose --header "Upscale factor:")
    [[ "$scale" == *"Main menu"* || -z "$scale" ]] && {
      pause_continue
      continue
    }

    model=$(
      printf "%b\n%s\n%s\n%s" \
        "realesr-animevideov3 (default)" \
        "realesrgan-x4plus (general)" \
        "realesrgan-x4plus-anime" \
        "$BACK_LABEL" |
        gum choose --header "AI Model:"
    )
    [[ "$model" == *"Main menu"* || -z "$model" ]] && {
      pause_continue
      continue
    }
    model_name=$(echo "$model" | awk '{print $1}')

    out_flag=$(ask_output_dir_flag)
    [ $? -eq 1 ] && {
      pause_continue
      continue
    }

    show_info "Upscaling with AI (${scale}x using $model_name)..."
    if output=$(gowall upscale $args -s "$scale" -m "$model_name" $out_flag 2>&1); then
      show_success "Upscaling complete."
      [ -n "$out_flag" ] && echo "  → Saved to: ${out_flag#--output }"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Compress image
  # --------------------------------------------------------
  *"Compress image"*)
    file=$(choose_file "Select image to compress:") || {
      pause_continue
      continue
    }

    method=$(
      printf "%b\n%s\n%s\n%s\n%s" \
        "pngquant (PNG lossy)" \
        "losslesspng" \
        "lossyjpg" \
        "lossywebp" \
        "$BACK_LABEL" |
        gum choose --header "Compression method:"
    )
    [[ "$method" == *"Main menu"* || -z "$method" ]] && {
      pause_continue
      continue
    }
    method_flag=$(echo "$method" | awk '{print $1}')

    quality=$(gum input --placeholder "Quality 0-100" --value "80")
    [ -z "$quality" ] && {
      pause_continue
      continue
    }

    flags="-m $method_flag -q $quality"
    out_flag=$(ask_output_path_flag)
    [ $? -eq 1 ] && {
      pause_continue
      continue
    }

    show_info "Compressing image..."
    if output=$(gowall compress "$file" $flags $out_flag 2>&1); then
      show_success "Image compressed."
      [ -n "$out_flag" ] && echo "  → Saved: ${out_flag#--output }"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Extract color palette
  # --------------------------------------------------------
  *"Extract color palette"*)
    file=$(choose_file "Select image:") || {
      pause_continue
      continue
    }
    num=$(gum input --placeholder "Number of colors" --value "6")
    [ -z "$num" ] && {
      pause_continue
      continue
    }

    preview_flag_choice=$(printf "No\nYes\n%s" "$BACK_LABEL" | gum choose --header "Open palette preview in browser?")
    [[ "$preview_flag_choice" == *"Main menu"* || -z "$preview_flag_choice" ]] && {
      pause_continue
      continue
    }
    preview_flag=""
    [ "$preview_flag_choice" = "Yes" ] && preview_flag="-p"

    show_info "Extracting color palette..."
    if output=$(gowall extract "$file" -c "$num" $preview_flag 2>&1); then
      show_success "Palette extracted."
      echo "$output"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Invert colors
  # --------------------------------------------------------
  *"Invert colors"*)
    input_mode=$(
      printf "%b\n%b\n%b\n%b" \
        "${ICON_ACCENT}${RESET}  Single image" \
        "${ICON_ACCENT}${RESET}  Multiple images" \
        "${ICON_ACCENT}${RESET}  Directory" \
        "$BACK_LABEL" |
        gum choose --header "Process:"
    )
    [[ "$input_mode" == *"Main menu"* || -z "$input_mode" ]] && continue

    args=""
    case $input_mode in
    *"Single image"*)
      file=$(choose_file "Select image:") || {
        pause_continue
        continue
      }
      args="$file"
      ;;
    *"Multiple images"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      files=$(find "$dir" -maxdepth 1 -type f \( -iname "*.png" -o -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.webp" \) -printf "%f\n")
      [ -z "$files" ] && {
        show_error "No images found"
        pause_continue
        continue
      }
      selected=$( (
        echo "$files"
        echo "Main menu"
      ) | gum filter --no-limit)
      [[ "$selected" == *"Main menu"* || -z "$selected" ]] && {
        pause_continue
        continue
      }
      batch_list=$(echo "$selected" | grep -v "^Main menu$" | sed "s|^|$dir/|" | paste -sd, -)
      args="--batch $batch_list"
      ;;
    *"Directory"*)
      dir=$(choose_directory "Select directory:") || {
        pause_continue
        continue
      }
      args="--dir $dir"
      ;;
    esac

    out_flag=$(ask_output_dir_flag)
    [ $? -eq 1 ] && {
      pause_continue
      continue
    }

    show_info "Inverting colors..."
    if output=$(gowall invert $args $out_flag 2>&1); then
      show_success "Colors inverted."
      [ -n "$out_flag" ] && echo "  → Saved to: ${out_flag#--output }"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # List themes
  # --------------------------------------------------------
  *"List themes"*)
    list_mode=$(
      printf "%b\n%b\n%b\n%b" \
        "${ICON_TEXT}${RESET}  List all themes" \
        "${ICON_ACCENT}${RESET}  Show theme colors" \
        "${ICON_BLUE}${RESET}  Preview palette" \
        "$BACK_LABEL" |
        gum choose --header "Themes:"
    )
    [[ "$list_mode" == *"Main menu"* || -z "$list_mode" ]] && continue

    if [[ $list_mode == *"List all themes"* ]]; then
      themes=$(gowall list 2>&1)
      if [ $? -eq 0 ]; then
        count=$(echo "$themes" | wc -l | tr -d ' ')
        gum style --foreground "$MOCHA_GREEN" --bold "Available themes ($count):"
        echo "$themes" | column -c "$(tput cols 2>/dev/null || echo 80)"
      else
        show_error "$themes"
      fi

    elif [[ $list_mode == *"Show theme colors"* ]]; then
      theme=$({
        echo -e "$theme_list"
        echo "$BACK_LABEL"
      } | gum choose --header "Select theme:")
      [[ "$theme" == *"Main menu"* || -z "$theme" ]] && {
        pause_continue
        continue
      }
      if output=$(gowall list -t "$theme" 2>&1); then
        gum style --foreground "$MOCHA_GREEN" "Colors in '$theme':"
        echo "$output"
      else
        show_error "$output"
      fi

    else
      theme=$({
        echo -e "$theme_list"
        echo "$BACK_LABEL"
      } | gum choose --header "Select theme:")
      [[ "$theme" == *"Main menu"* || -z "$theme" ]] && {
        pause_continue
        continue
      }
      if output=$(gowall list -p -t "$theme" 2>&1); then
        show_success "Preview opened."
        echo "$output"
      else
        show_error "$output"
      fi
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # OCR
  # --------------------------------------------------------
  *"OCR (extract text)"*)
    file=$(choose_file "Select image/PDF:") || {
      pause_continue
      continue
    }

    provider=$(printf "tesseract\ndocling\nopenrouter\ngemini\n%s" "$BACK_LABEL" | gum choose --header "OCR Provider:")
    [[ "$provider" == *"Main menu"* || -z "$provider" ]] && {
      pause_continue
      continue
    }

    flags="-p $provider"
    if [[ "$provider" != "tesseract" && "$provider" != "docling" ]]; then
      model=$(gum input --placeholder "Model name (e.g. google/gemini-2.0-flash-exp)")
      [ -n "$model" ] && flags="$flags -m $model"
    fi

    lang=$(gum input --placeholder "Language (eng, ita, etc)" --value "eng")
    [ -n "$lang" ] && flags="$flags -l $lang"

    fmt=$(printf "md\ntxt\n%s" "$BACK_LABEL" | gum choose --header "Output format:")
    [[ "$fmt" == *"Main menu"* || -z "$fmt" ]] && {
      pause_continue
      continue
    }
    [ "$fmt" = "txt" ] && flags="$flags -f txt"

    show_info "Performing OCR..."
    if output=$(gowall ocr "$file" $flags 2>&1); then
      show_success "OCR complete."
      echo "$output" | gum pager
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Wallpaper of the day
  # --------------------------------------------------------
  *"Wallpaper of the day"*)
    show_info "Fetching wallpaper of the day..."
    if output=$(gowall -w 2>&1); then
      show_success "Wallpaper retrieved."
      echo "$output"
    else
      show_error "$output"
    fi
    pause_continue
    ;;

  # --------------------------------------------------------
  # Exit
  # --------------------------------------------------------
  *"Exit"*)
    clear
    gum style --foreground "$MOCHA_ACCENT" --bold "Thanks for using manu-gowall-tool!"
    exit 0
    ;;

  esac
done
